<body>
<script>
	const model =
		{
			name: "Architecture_candidate",
			classes: String.raw`
				package SB_IHM {
					class GUI <<active>>{
						-screenList : Screen
						-curentRobot : Robot
						-selectedRobot : Robot
						-streamRefreshRate : Integer
						-selectedLogs : IdFile
						-robotList : Robot
						-logList : Log
						start()
						commandRobot()
						selectRobot(idRobot)
						moveRobot(selectedRobot, cmd)
						editRobotMode(selectedRobot, operatingMode)
						modeReady()
						returnHome()
						consultLogs()
						selectLogs(idFile)
						setLogs(logList)
						exportLogs(idFile)
						logsExported(idFile)
						notifyError(idError)
						validate()
						raiseMemoryAlert(idRobot)
						flush()
						initReady()
						logsReady(idFile, logList)
						ackCmd(idRobot, cmd)
						quit()
						stop()
						-refreshCameraStream(image, idRobot)
						-refreshRadarStream(radar, idRobot)
						-displayScreen(idScreen, robotList)
						-displayLogs(idFile, logList)
						-updateCurrentScreen(robotList)
						-displayPopUp(idPopup, idRobot)
						-pickFirstRobot(robotList)
						-pickNextRobot(robotList)
						-consultRobotMode(robotList, idRobot)
						-authorizeRobotCommand()
						-denyRobotCommand()
						-terminate()
					}
					class ConfigReader {
						-config : Config
						getRobotListFromConfig() : Robot
						-parseConfig(config) : Robot
					}
					class Viewer {
						-camera : Image
						setCamera(idRobot, image)
						getLastCamera(idRobot) : Image
						setupRobotPort(idRobot)
					}
					class LogsManager <<active>>{
						-logList : Log
						-fileList : IdFile[*]
						-selectedLogs : IdFile
						-level : Integer
						-checkedFile : Bool
						-flushTimeout : Integer
						initFileList(robotList)
						setLogs(logList)
						setSelectedLogs(idFile)
						log(level, msg)
						checkFlushedSavedLogsFile(idFile)
						askLogsExport(idFile)
						transmitRtc(idRobot)
						-addLogsToList(log, logList)
						-updateLogList(logList)
						-setFileList(robotList)
						-checkFile(idFile)
						-createFlushedLogsFile(idFile)
						-saveLogs(log)
						-loadLogs(selectedLogs) : logList
						-exportLogsWithOS(idFile)
						-checkExport()
					}
					class GUISecretary <<active>>{
						-robotList : Robot
						-selectedRobot : Robot
						-currentRobot : Robot
						-timeOutConnection : Integer
						-timeOutDisconnection : Integer
						askInit()
						getRobotList() : Robot
						setSelectedRobot(idRobot)
						setMode(idRobot, operatingMode)
						changeMode(selectedRobot, operatingMode)
						disconnectedOk(idRobot)
						ackConnection(idRobot)
						disconnectRobots()
						setModeInit()
						notifyVarReady(idRobot)
						notifyDisconnectedRobot(idRobot)
						reconnectingRobots()
						setRadar(idRobot, myRadar)
						-pickFirstRobot(robotList)
						-pickNextRobot(robotList)
						-updateDisconnectedRobot(currentRobot, robotList)
						-updateConnectedRobot(currentRobot, robotList)
						-getRobotFromRobotList(idRobot) : Robot
					}
					class GUIRinger <<active>>{
						-timeOutPongs : Integer
						-maxFailedPongs : Integer
						-failedPongs : Integer
						-refreshPingPeriod : Integer
						-currentRobot : Robot
						-robotList : Robot
						setAvailability(idRobot)
						checkFailedPongVar(idRobot)
						initOK()
						-checkFailedPongs(idRobot)
						-createFailedPongVar(idRobot)
						-updateFailedPongs(value, idRobot)
						-pickFirstRobot(robotList)
						-pickNextRobot(robotList)
						-setRobotToDisconnected(idRobot)
					}
				}
				package SB_C {
					class ControllerRinger <<active>>{
						-failedPings : Integer
						-maxFailedPings : Integer
						-timeOutPings : Integer
						askAvailability(idRobot) : void
						initFailedPingsVar() : void
						-updateFailedPings(value) : void
						-checkFailedPings() : void
					}
					class ControllerCore <<active>>{
						-idRobot : Integer
						-robotOperatingMode : OperatingMode
						-robotState : State
						askToConnect(idRobot) : void
						askToDisconnect(idRobot) : void
						askSetState(idRobot, state) : void
						askMode(idRobot) : void
						askSetMode(idRobot, operatingMode) : void
						getIdRobot() : Integer
						getMode() : OperatingMode
						connectionLost() : void
						-disconnectCore() : void
						-setOperatingMode(operatingMode) : OperatingMode
						-applyEditMode(operatingMode) : void
						-initHardware() : void
					}
					class ControllerLogger <<active>>{
							-level : IdLevel
							-idFile : IdFile
							-idTempFile : IdFile
							-filePath : String
							-currentFileSize : Integer
							-logList : Log
							-robotRtc : Time
							-printModeSet : Integer

							+askLogs(idRobot) : void
							+log(level, msg) : void
							+askSetRtc(idRobot, rtc) :  void
							+logsSaved(idRobot) : void
							-setUpRtc(rtc) : void
							-checkMemory() : Integer
							-storeTempLogs(log) : void
							-saveTempLogs() : void
							-saveLogs(string,level) : void
							-loadLogs() : logList
							-removeLogs() : void
							-getCurrentTime(buffer) : void
					}
					class Camera <<active>>{
						-refreshPeriod : Integer
						-guiIp : IpAdress
						-guiPort : Integer
						+setupGUIInfo(ip, port) : void
						+disconnectCamera() : void
						+enableCamera() : void
						+disableCamera() : void
						-updateCamera() : Image
					}
					class Radar {

						getRadar() : Radar
					}
					class Pilot <<active>>{
						-ObstacleRefreshPeriodCheck : Integer
						-obstacleState : Boolean
						askCmd(cmd) : void
						-moveRobot(cmd) : void
					}
					class StateIndicator <<active>>{
						-ledActivated : Bool
						-buzzerActivated : Bool
						-currentState : State
						-emergencyTimeOut : Integer
						+setState(state) : void
						+enableBuzzer() : void
						+disableBuzzer() : void
						+enableLED() : void
						+disableLED() : void
						-flashingForConnection() : void
						-notifyNotSelected() : void
						-notifySelected() : void
						-notifyEmergency() : void
					}
				}

				GUISecretary  	"1" -> "1"  ConfigReader
				GUISecretary  	"1" -> "1"  Viewer
				GUISecretary  	"1" <-> "1"  GUIRinger
				GUI  			"1" <-> "1"  GUISecretary
				GUI  			"1" <-> "1"  LogsManager
				GUI  			"1" -> "1"  Viewer

				Pilot  			"1" -> "1"  ControllerLogger
				Camera  		"1" -> "1"  ControllerLogger
				StateIndicator  "1" -> "1"  ControllerLogger
				ControllerCore  "1" -> "1"  ControllerLogger
				ControllerCore  "1" <-> "1"  ControllerRinger
				ControllerCore  "1" <-> "1"  Camera
				ControllerCore  "1" -> "1"  StateIndicator
				ControllerCore  "1" <-> "1"  Pilot
				Pilot  			"1" -> "1"  StateIndicator
				Pilot  			"1" -> "1"  Radar

				GUI  			"1" <-> "1..n"  Pilot
				LogsManager  	"1" <-> "1..n"  ControllerLogger
				GUISecretary  	"1" <-> "1..n"  ControllerCore
				Viewer  		"1" <-> "1..n"  Camera
				GUIRinger  		"1" <-> "1..n"  ControllerRinger
			`,
			objects: [
				{
					name: "user",
					class: "User",
					isActor: true,
					features: String.raw`
					`,
				},
				{
					name: "gui",
					class: "GUI",
					packagePath: [
						"SB_IHM",
					],
					behavior: String.raw`

					state "PopUpError" as PopUpError {
					}
					state "PopUpFlush" as PopUpFlush {
					}
					state "Disconnecting" as Disconnecting {
					}
					state "GUI" as GUI {

						state "HomeInit" as HomeInit {
						}
						state "HomeConnectedRobots" as HomeConnectedRobots {
						}
						state "HomeNoRobotAvailable" as HomeNoRobotAvailable {
						}
						state "WaitingMode" as WaitingMode {
						}

						state "Command" as Command{
							state "NoRobotSelected" as NoRobotSelected {
							}
							state "RobotSelected" as RobotSelected {
								state "WaitingOrder" as WaitingOrder {
								}
								state "WaitingResponse" as WaitingResponse {
								}
								[*] -> WaitingOrder
								WaitingOrder -> WaitingResponse : moveRobot(selectedRobot, cmd) / log(INFO, msg); robotList = getRobotList(); updateCurrentScreen(robotList); askCmd(cmd) ; log(DEBUG, cmd) ;
								note on link
														cmd = FORWARD, BACKWARD, RIGHT, LEFT, STOP
														idRobot = selectedRobot.idRobot
								end note
								WaitingResponse -> WaitingOrder : ackCmd(idRobot, cmd) / log(DBEUG, msg);

							}
							[*] -> NoRobotSelected
							NoRobotSelected -> RobotSelected : selectRobot(idRobot)/log(INFO, msg);setSelectedRobot(idRobot); robotList = getRobotList(); authorizeRobotCommand(); log(INFO, mgs); updateCurrentScreen(robotList);
							RobotSelected -> RobotSelected : selectRobot(idRobot)/setSelectedRobot(idRobot); robotList = getRobotList(); authorizeRobotCommand(); log(INFO, mgs); updateCurrentScreen(robotList);
							RobotSelected -> RobotSelected : editRobotMode(selectedRobot, operatingMode)/log(INFO, msg); changeMode(selectedRobot,operatingMode); robotList = getRobotList(); updateCurrentScreen(robotList);
						}
						state "Logs" as Logs {
							state "NoLogsSelected" as NoLogsSelected {
							}
							state "WaitingRobotLogs" as WaitingRobotLogs {
							}
							state "WaitingGUILogs" as WaitingGUILogs {
							}
							state "LogsSelected" as LogsSelected {
							}
							state "choice" as choice <<choice>>
							state "choice2" as choice2 <<choice>>

							WaitingRobotLogs : entry / setSelectedLogs(RobotXLogsFile);
							WaitingGUILogs : entry / setSelectedLogs(GUILogsFile);

							[*] -> NoLogsSelected : / robotList = getRobotList(); displayScreen(idScreen, robotList);

							NoLogsSelected -> choice : selectLogs(idFile)/log(INFO, msg);
							choice -> WaitingGUILogs : [idFile == GUILogsFile] /
							choice -> WaitingRobotLogs : [else] /

							WaitingRobotLogs -> LogsSelected : logsReady(RobotXLogsFile,logList) /
							WaitingGUILogs -> LogsSelected : logsReady(GUILogsFile,logList) /

							LogsSelected : entry/displayLogs(idFile,logList);log(INFO, msg);
							LogsSelected -> LogsSelected : exportLogs(idFile)

							LogsSelected -> choice2 : selectLogs(idFile)/log(INFO, msg);
							choice2 -> WaitingGUILogs : [idFile == GUILogsFile] /
							choice2 -> WaitingRobotLogs : [else] /
						}
						state "choice" as choice <<choice>>
						state "choice" as choice2 <<choice>>

						HomeInit : entry/log(INFO, msg); displayScreen(HOME_SCREEN, robotList); askInit();

						[*] -> HomeInit
						HomeInit -> choice : initReady() / robotList = getRobotList(); updateCurrentScreen(robotList); initFileList(robotList);

						choice -> HomeNoRobotAvailable : [robotList == null]
						choice -> HomeConnectedRobots : [else]

						HomeConnectedRobots : entry / updateCurrentScreen(robotList)

						HomeConnectedRobots -> WaitingMode : commandRobot()/log(INFO, msg); setModeInit();
						WaitingMode -> Command : modeReady()/robotList = getRobotList(); displayScreen(COMMAND_SCREEN, robotList);
						Command -> HomeInit : returnHome()/reconnectingRobots()
						Command -> Logs : consultLogs()/log(INFO, msg);
						Logs -> Command : commandRobot()/robotList = getRobotList(); displayScreen(LOGS_SCREEN, robotList); log(INFO, msg);

						Command -> StreamRefresh : after(streamRefreshRate) / robotList = getRobotList(); pickFirstRobot(robotList);
						StreamRefresh : do/refreshRadarStream(radar,idRobot);consultRobotMode(robotList,idRobot);image=getLastCamera(idRobot);refreshCameraStream(image,idRobot);
						StreamRefresh -> choice2 : / currentRobot = pickNextRobot(robotList);
						choice2 -> StreamRefresh : [else]
						choice2 -> Command[H] : [currentRobot == null]
						note on link
												Vers [H*]
						end note
					}

					GUI -> PopUpError : notifyError(idError) / log(ERROR, msg);
					GUI -> PopUpFlush : raiseMemoryAlert(idRobot) / log(DEBUG, msg);
					PopUpError -> GUI[H] : validate() / log(INFO, msg);
					note on link
											Vers [H*]
					end note
					PopUpFlush -> GUI[H] : flush()
					note on link
											Vers [H*]
					end note
					PopUpFlush : entry/displayPopUp(idPopup, idRobot); log(INFO, msg);
					PopUpError : entry/displayPopUp(idPopup, idRobot); log(INFO, msg);

					[*] -> GUI
					GUI -> Disconnecting : quit()/disconnectRobots();

					Disconnecting -> [*] : stop()/log(INFO, msg); terminate();

					`,
					features: String.raw`
						-screenList : Screen[*]
						-currentRobot : Robot
						-selectedRobot : Robot
						-streamRefreshRate : Integer
						-selectedLogs : IdFile
						-robotList : Robot[*]
						-logList : Log[*]

						+start()
						+commandRobot()
						+selectRobot(idRobot)
						+moveRobot(selectedRobot, cmd)
						+editRobotMode(selectedRobot, operatingMode)
						+modeReady()
						+returnHome()
						+consultLogs()
						+selectLogs(idFile)
						+setLogs(logList)
						+exportLogs(idFile)
						+logsExported(idFile)
						+notifyError(idError)
						+validate()
						+raiseMemoryAlert(idRobot)
						+flush()
						+initReady()
						+logsReady(idFile, logList)
						+ackCmd(idRobot, cmd)
						+quit()
						+stop()

						-refreshCameraStream(image,idRobot)
						-refreshRadarStream(radar,idRobot)
						-displayScreen(idScreen, robotList)
						-displayLogs(idFile, logList)
						-updateCurrentScreen(robotList)
						-displayPopUp(idPopup, idRobot)
						-pickFirstRobot(robotList)
						-pickNextRobot(robotList)
						-consultRobotMode(robotList, idRobot)
						-authorizeRobotCommand()
						-denyRobotCommand()
						-terminate()
					`,
				},{
					name: "robot",
					class: "Robot",
					packagePath: [
						"SB_IHM",
					],
					features: String.raw`
						-id : Integer
						-ipAdress : String
						-macAdress : String
						-port : Integer
						-connectionState : ConnectionState
						-ObstacleDetection : ObstacleDetection 
						-selectionState : SelectionState 
						-operatingMode : OperatingMode
						-failedPings : Integer

						+setConnectedState() 
						+setDisconnectedState() 
						+setSelectedState() 
						+SetUnselectedState() 
						+setObstacleDetectionTrue() 
						+setObstacleDetectionFalse() 
					`,
				},
				{
					name: "configReader",
					class: "ConfigReader",
					packagePath: [
						"SB_IHM",
					],
					features: String.raw`
						-config : Json

  						+getRobotListFromConfig() : Robot[*]
						-parseConfig(config) : Robot[*]
					`,
				},
				{
					name: "viewer",
					class: "Viewer",
					packagePath: [
						"SB_IHM",
					],
					stereotypes: [
						"active",
					],
					behavior: String.raw`
						[*] --> Idle : /start(); 
						Idle --> ReceivingImage : setupRobotPort(robotList) / initInfoClients(robotList); 
						ReceivingImage : setCamera(idRobot, image) 
                    `,
					features: String.raw`
						-camera: Image[*]

						+setCamera(idRobot, image)
						+getLastCamera(idRobot) : Image
						+setupRobotPort(idRobot)

						-initInfoClients(robotList)
					`,
				},
				{
					name: "logsManager",
					class: "LogsManager",
					packagePath: [
						"SB_IHM",
					],
					stereotypes: [
						"entity",
					],
					behavior: String.raw`
						state "Logging" as Logging {
							state choice <<choice>>
							state choice2 <<choice>>
							state choice3 <<choice>>
							state choice4 <<choice>>
							state "Idle" as Idle {
							}
							state "Flushing" as Flushing {
							}
							state "Exporting" as Exporting{

							}
							Flushing : entry / askLogs(idRobot)

							[*] -> Idle :

							choice2 -> Idle : [checkedFile==false] / createFlushedLogsFile(idFile);
							choice2 -> Idle : [else]

							Idle : initFileList(robotList) / fileList = setFileList(robotList);

							Idle -> choice : setSelectedLogs(idFile) / selectedLogs = idFile;
							Idle : log(level, msg) / logList = null; addLogsToList(msg, logList); selectedLogs = GUILogFile; saveLogs(selectedLogs, logList);
							Idle : transmitRtc(idRobot)/askSetRtc(idRobot, rtc); logList = null; addLogsToList(msg, logList)); saveLogs(GUILogFile, logList);
							choice -> Idle : [else] / logList = loadLogs(selectedLogs); logsReady(selectedLogs, logList);
							choice -> Flushing : [selectedLogs == ROBOTxFlushedLogFile] /
							Flushing -> Idle : setLogs(logList) / logList = updateLogList(logList); saveLogs(selectedLogs, logList); logsSaved(idRobot); logsReady(selectedLogs, logList);
							Flushing -> Idle : after(flushTimeout)/logList=null; logsReady(selectedLogs, logList);
							Idle -> choice3 : askLogsExport(selectedLogs)/
							choice3 -> Exporting : [selectedLogs!=null]
							choice3 -> Idle : [else]/notifyError(ERROR_SOURCE_LOG_SELECTION);
							Exporting : do/exportLogsWithOS(selectedLogs);
							Exporting -> choice4 : /export = checkExport();
							choice4 -> Idle : [export==true]/logsExported(selectedFile);
							choice4 -> Idle : [else]/logsExported(selectedFile);notifyError(ERROR_SOURCE_LOG_EXPORT);
						}

						[*] --> Logging :
						Logging -> Logging.choice2 : checkFlushedSavedLogsFile(idFile) / checkedFile = checkFile(idFile);

					`,
					features: String.raw`
						-logList : Log[*]
						-fileList : IdFile[*]
						-selectedLogs : IdFile
						-level : LogLevel
						-checkedFile : Boolean
						-flushTimeout : Integer

						+initFileList(robotList)
						+setLogs(logList)
						+setSelectedLogs(idFile)
						+log(level, msg)
						+checkFlushedSavedLogsFile(idFile)
						+askLogsExport(idFile)
						+transmitRtc(idRobot)

						-addLogsToList(log, logList)
						-updateLogList(logList)
						-setFileList(robotList)
						-checkFile(idFile)
						-createFlushedLogsFile(idFile)
						-saveLogs(log)
						-loadLogs(selectedLogs) : logList
						-exportLogsWithOS(idFile)
						-checkExport()
					`,
				},
				{
					name: "guiSecretary",
					class: "GUISecretary",
					packagePath: [
						"SB_IHM",
					],
					behavior: String.raw`

					state "choice" as choice <<choice>>
					state "choice" as choice2 <<choice>>
					state "choice" as choice3 <<choice>>
					state "choice" as choice_after_connection1 <<choice>>
					state "choice" as choice_empty_list <<choice>>
					state "choice" as choice_select <<choice>>
					state "choice" as choice_disconnect <<choice>>
					[*] -> Idle
					Idle -> choice_empty_list : askInit()/robotList = getRobotListFromConfig();

					choice_empty_list -> FinishForEmptyList : [robotList == null]/initReady();
					choice_empty_list -> WaitingForConnection : [else]/currentRobot = pickFirstRobot(robotList);

					WaitingForConnection : entry/askToConnect(currentRobot.idRobot); log(DEBUG, msg);

					WaitingForConnection -> WaitingForFlushedFile : ackConnection(idRobot)/log(INFO, msg);checkFlushedSavedLogsFile(RobotXLogsFile);checkFailedPongVar(currentRobot.idRobot);
					WaitingForFlushedFile -> choice : notifyVarReady(idRobot)/transmitRtc(currentRobot.idRobot);setupRobotPort(idRobot);log(DEBUG,msg);updateConnectedRobot(currentRobot, robotList);currentRobot = pickNextRobot(robotList);

					WaitingForConnection -> choice_after_connection1 : after(timeOutConnection)/log(WARNING, msg);updateDisconnectedRobot(currentRobot, robotList);currentRobot = pickNextRobot(robotList);
					choice_after_connection1 -> WaitingForConnection : [else]
					choice_after_connection1 -> Available : [currentRobot == null]/initOK();initReady();

					choice -> WaitingForConnection : [else]
					choice -> Available : [currentRobot == null]/initOK();initReady();

					Available -> WaitingForMode : setModeInit()/currentRobot = pickFirstRobot(robotList);

					WaitingForMode : entry/askMode(currentRobot.idRobot);log(DEBUG, msg);

					WaitingForMode -> choice3 : setMode(idRobot, operatingMode)/log(DEBUG, msg);currentRobot=pickNextRobot(robotList);
					choice3 -> WaitingForMode : [else]/askSetState(idRobot,state);
					choice3 -> Available : [currentRobot == null]/modeReady();

					Available : notifyDisconnectedRobot(idRobot)/updateDisconnectedRobot(idRobot, robotList);
					Available : changeMode(selectedRobot,operatingMode)/askSetMode(idRobot,operatingMode);log(DEBUG,msg);
					Available : setRadar(idRobot, myRadar)/log(DEBUG, msg);
					Available -> choice_select : setSelectedRobot(idRobot)

					choice_select -> Available : [selectedRobot != null]/askSetState(selectedRobot.idRobot,NOT_SELECTED);log(DEBUG,msg);selectedRobot=getRobotFromRobotList(idRobot);askSetState(idRobot,SELECTED);log(DEBUG,msg);
					choice_select -> Available : [else]/selectedRobot=getRobotFromRobotList(idRobot);askSetState(idRobot,SELECTED);log(DEBUG,msg);

					Available -> WaitingForConnection : reconnectingRobots()/currentRobot = pickFirstRobot(robotList);

					Available -> WaitingForDisconnection : disconnectRobots()/currentRobot = pickFirstRobot(robotList);
					WaitingForDisconnection : entry / askToDisconnect(currentRobot.idRobot);log(DEBUG, msg);
					WaitingForDisconnection ->  choice2 : disconnectedOk(currentRobot.idRobot)/log(DEBUG, msg);updateDisconnectedRobot(currentRobot, robotList); currentRobot = pickNextRobot(robotList);
					WaitingForDisconnection ->  choice_disconnect : after(timeOutDisconnection)/log(ERROR, msg);notifyError(ROBOT_CONNECION_ERROR);currentRobot = pickNextRobot(robotList);

					choice_disconnect -> WaitingForDisconnection : [else]
					choice_disconnect -> [*] : [currentRobot == null]/stop();

					choice2 -> WaitingForDisconnection : [else]
					choice2 -> [*] : [currentRobot == null]/stop();

					`,
					features: String.raw`
						-robotList: Robot[*]
						-selectedRobot : Robot
						-currentRobot : Robot
						-timeOutConnection : Integer
						-timeOutDisconnection : Integer

						+askInit()
						+getRobotList(): Robot[*]
						+setSelectedRobot(idRobot)
						+setMode(idRobot, operatingMode)
						+changeMode(selectedRobot, operatingMode)
						+disconnectedOk(idRobot)
						+ackConnection(idRobot)
						+disconnectRobots()
						+setModeInit()
						+notifyVarReady(idRobot)
						+notifyDisconnectedRobot(idRobot)
						+reconnectingRobots()
						+setRadar(idRobot, myRadar)

						-pickFirstRobot(robotList)
						-pickNextRobot(robotList)
						-updateDisconnectedRobot(idRobot, robotList)
						-updateConnectedRobot(idRobot, robotList)
						-getRobotFromRobotList(idRobot) : Robot
					`,
				},
				{
					name : "guiRinger",
					class: "GUIRinger",
					packagePath: [
						"SB_IHM",
					],
					behavior: String.raw`
						InitVarRobot : entry / createFailedPongVar(idRobot) ; updateFailedPongs(0,idRobot) ; notifyVarReady(idRobot)
						Init : entry / robotList = getRobotList() ; currentRobot = pickFirstRobot(robotList)
						SendingPing : entry / askAvailability(currentRobot.idRobot);log(DEBUG,msg);
						PongReceived : entry / updateFailedPongs(0, currentRobot.idRobot)

						[*] --> WaitingSecretary : /
						WaitingSecretary --> InitVarRobot : checkFailedPongVar(idRobot) /
						InitVarRobot --> InitVarRobot : checkFailedPongVar(idRobot)
						InitVarRobot --> Init : initOK()
						Init --> SendingPing : after(refreshPingPeriod)
						SendingPing --> PongReceived : setAvailability(idRobot)/log(DEBUG,msg);

						state a <<choice>>
						SendingPing --> a : after(timeOutPongs) / checkFailedPongs(curentRobot.idRobot);

						state choice_pickNextRobot <<choice>>
						state choice_pickNextRobot2 <<choice>>
						state choice_pickNextRobot3 <<choice>>
						choice_pickNextRobot -> SendingPing : [currentRobot != null]
						choice_pickNextRobot -> Init : [else] /
						choice_pickNextRobot2 -> SendingPing : [currentRobot != null]
						choice_pickNextRobot2 -> Init : [else] /
						choice_pickNextRobot3 -> SendingPing : [currentRobot != null]
						choice_pickNextRobot3 -> Init : [else] /
						PongReceived --> choice_pickNextRobot : after(refreshPingPeriod) / currentRobot = pickNextRobot(robotList)
						a --> choice_pickNextRobot2 : [currentRobot.failedPongs == maxFailedPongs] / setRobotToDisconnected(currentRobot.idRobot) ; notifyDisconnectedRobot(idRobot) ; currentRobot = pickNextRobot(robotList)
						a --> choice_pickNextRobot3 : [else] / updateFailedPongs( 1	, currentRobot.idRobot) ; currentRobot = pickNextRobot(robotList)
                    `,
					features : String.raw`
						-timeOutPongs : Integer
						-maxFailedPongs : Integer
						-failedPongs : Integer[*]
						-refreshPingPeriod : Integer
						-currentRobot : Robot
						-robotList : Robot[*]

						+setAvailability(idRobot)
						+checkFailedPongVar(idRobot)
						+initOK()

						-checkFailedPongs(idRobot)
						-createFailedPongVar(idRobot)
						-updateFailedPongs(value, idRobot)
						-pickFirstRobot(robotList)
						-pickNextRobot(robotList)
						-setRobotToDisconnected(idRobot)
					`,
				},
				{
					name:"controllerRinger",
                    class:"ControllerRinger",
					packagePath: [
						"SB_C",
					],
					behavior: String.raw`
						state "Connected" as Connected {

							state "b" as b <<choice>>

							state "WaitingPing" as WaitingPing {
							}
							WaitingPing :
							state "WaitingEndInit" as WaitingEndInit {
							}
							[*] -> WaitingEndInit as "init2WaitingEndInit_1" : /
							WaitingEndInit -> WaitingPing as "WaitingEndInit2WaitingPing_1" : askAvailability(idRobot) / updateFailedPings(0);log(DEBUG,msg);setAvailability(idRobot);log(DEBUG,msg);
							WaitingPing -> b as "WaitingPing2b_1" : after(timeOutPings) / checkFailedPings()
							b -> WaitingPing as "b2WaitingPing_1" : [failedPings <= maxFailedPings] / updateFailedPings(failedPings + 1);
							b -> [*] as "b2__end___1" : [failedPings == maxFailedPings] / connectionLost();
							WaitingPing -> WaitingPing as "WaitingPing2WaitingPing_1" : askAvailability(idRobot) / updateFailedPings(0);log(DEBUG,msg);setAvailability(idRobot);log(DEBUG,msg);
						}
						state "Disconnected" as Disconnected {
						}
						[*] -> Disconnected as "init2Disconnected_1" : /
						Disconnected -> Connected as "Disconnected2Connected_1" : initFailedPingsVar() / updateFailedPings(0);
						Connected -> Disconnected as "Connected2Disconnected_1" : /
					`,
					features: String.raw`
						-failedPings : Integer
						-maxFailedPings : Integer
						-timeOutPings  : Integer

						+askAvailability(idRobot) : void
						+initFailedPingsVar() : void

						-updateFailedPings(value) : void
						-checkFailedPings() : void
                    `,
                },
				{
					name: "controllerCore",
					class: "ControllerCore",
					packagePath: [
						"SB_C",
					],
					behavior: String.raw`
						state "Disconnected" as Disconnected {
						}
						Disconnected : entry / log(INFO,msg); robotState = WAITING_FOR_CONNECTION; setState(robotState);

						state "Connected" as Connected {
							state "a" as a <<choice>>

							state "WaitingAction" as WaitingAction {
							}
							WaitingAction as "T1" : askMode(idRobot) / setMode(idRobot, robotOperatingMode);
							WaitingAction as "T2" : askSetMode(idRobot, operatingMode) / robotOperatingMode = setOperatingMode(operatingMode); applyEditMode(robotOperatingMode);
							[*] -> WaitingAction as "init2WaitingAction_1" : /
							WaitingAction -> a as "WaitingAction2a_1" : askSetState(idRobot, state) /
							a -> WaitingAction as "a2WaitingAction_1" : [else] / robotState = NOT_SELECTED; setState(robotState);
							a -> WaitingAction as "a2WaitingAction_2" : [state == SELECTED] / robotState = SELECTED; setState(robotState);
						}
						Connected : entry / ackConnection(idRobot); initFailedPingsVar(); robotState = NOT_SELECTED; setState(robotState) ;
						[*] -> Disconnected as "init2Disconnected_1" : / initHardware()
						Disconnected -> Connected as "Disconnected2Connected_1" : askToConnect(idRobot) /
						Connected -> Disconnected as "Connected2Disconnected_1" : askToDisconnect(idRobot) / disconnectedOk(idRobot); disconnectCore(); askCmd(STOP); disconnectCamera()
						Connected -> Disconnected as "Connected2Disconnected_2" : connectionLost() / disconnectCore(); askCmd(STOP); disconnectCamera()
					`,
					features: String.raw`
						-idRobot : Integer
						-robotOperatingMode : OperatingMode
						-robotState : State

						+askToConnect(idRobot) : void
						+askToDisconnect(idRobot) : void
						+askSetState(idRobot, state) : void
						+askMode(idRobot) : void
						+askSetMode(idRobot, operatingMode) : void
						+getIdRobot() : Integer
						+getMode() : OperatingMode
						+connectionLost() : void
						-disconnectCore() : void
						-setOperatingMode(operatingMode) : OperatingMode
						-applyEditMode(operatingMode) : void
						-initHardware() : void
					`,
				},
				{
					name: "controllerLogger",
					class: "ControllerLogger",
					packagePath: [
						"SB_C",
					],
					features: String.raw`
							-level : IdLevel
							-idFile : IdFile
							-idTempFile : IdFile
							-filePath : String
							-currentFileSize : Integer
							-logList : Log
							-robotRtc : Time
							-printModeSet : Integer

							+askLogs(idRobot) : void
							+log(level, msg) : void
							+askSetRtc(idRobot, rtc) :  void
							+logsSaved(idRobot) : void
							-setUpRtc(rtc) : void
							-checkMemory() : Integer
							-storeTempLogs(log) : void
							-saveTempLogs() : void
							-saveLogs(string,level) : void
							-loadLogs() : logList
							-removeLogs() : void
							-getCurrentTime(buffer) : void
					`,
					behavior : String.raw`
						state "WaitingAction" as WaitingAction {
						}
						state "MemoryFull" as MemoryFull {
						}
						state "Flushing" as Flushing {
						}
						state "Idle" as Idle {
						}
						state "choice" as choice <<choice>>

						[*] -> Idle
						Idle -> WaitingAction  : askSetRtc(idRobot, rtc) / robotRtc = rtc; setUpRtc(robotrtc); saveTempLogs();
						Idle -> Idle : log(level, msg) / my_log = level + msg; storeTempLogs(my_log);
						WaitingAction -> choice as "WaitingAction2Choice_1" : log(level, msg) / currentFileSize = checkMemory();
						choice -> WaitingAction as "choice2WaitingAction_1" : [currentFileSize < 1,5Mo] / saveLogs(msg,level);
						choice -> WaitingAction as "choice2WaitingAction_2" : [currentFileSize >= 1,5Mo && currentFileSize < 2Mo] / raiseMemoryAlert(idRobot);
						choice -> MemoryFull as "choice2MemoryFull_1" : [else] / raiseMemoryAlert(idRobot);
						MemoryFull -> Flushing as "MemoryFull2Flushing_1" : askLogs(idRobot) / logList = loadLogs();
						WaitingAction -> Flushing as "WaitingAction2Flushing_1": askLogs(idRobot) / logList = loadLogs();
						Flushing : entry / setLogs(log);
						Flushing -> WaitingAction as "Flushing2WaitingAction_1": logsSaved(idRobot) / removeLogs();
					`,
				},
				{
					name: "camera",
					class: "Camera",
					packagePath: [
						"SB_C",
					],
					behavior: String.raw`
						state "WaitingGUIInfo" as WaitingGUIInfo {
						}

						state "GUIReady" as GUIReady {
							state "CameraOFF" as CameraOFF {
							}
							state "CameraON" as CameraON {
							}
							[*] -> CameraON : /
							CameraON -> CameraON : after(refreshPeriod) / myImage = updateCamera(); myIdRobot = getIdRobot(); setCamera(myIdRobot,myImage);
							CameraOFF -> CameraON : enableCamera() / log(INFO, msg)
							CameraON -> CameraOFF : disableCamera() / log(INFO, msg)
						}

						[*] -> WaitingGUIInfo : /
						WaitingGUIInfo -> GUIReady : setupGUIInfo(ip,port) / guiIp = ip; guiPort = port; log(DEBUG, msg)
						GUIReady -> WaitingGUIInfo : disconnectCamera()
					`,
					features: String.raw`
						-refreshPeriod : Integer
						-guiIp : IpAdress
						-guiPort : Integer
						+setupGUIInfo(ip, port) : void
						+disconnectCamera() : void
						+enableCamera() : void
						+disableCamera() : void
						-updateCamera() : Image
					`,
				},
				{
					name: "radar",
					class: "Radar",
					packagePath: [
						"SB_C",
					],
					features: String.raw`
						+getRadar() : Radar
					`,
				},
				{
					name: "pilot",
					class: "Pilot",
					packagePath: [
						"SB_C",
					],
					behavior: String.raw`
						state "choice1" as choice1 <<choice>>
						state "Piloting" as Piloting {
							state "choice" as choice <<choice>>
							state "Idle" as Idle
							state "MoveForward" as MoveForward

							[*] -> Idle :
							choice -> MoveForward : [cmd==FORWARD] / moveRobot(cmd); log(INFO, msg);
							choice -> Idle : [else] / moveRobot(cmd); log(INFO, msg);
							MoveForward -> Idle : when(obstacleState==TRUE) / cmd=STOP; moveRobot(cmd); \n log(INFO, msg); setState(EMERGENCY)
						}
						[*] -> Piloting :    /
						Piloting -> Piloting.choice : askCmd(cmd) / log(DEBUG, msg); \n myIdRobot = getIdRobot(); ackCmd(myIdRobot,cmd); log(DEBUG, msg);
						Piloting -> choice1 : after(ObstacleRefreshPeriodCheck) / operatingMode = getMode()
						choice1 -> Piloting[H] : [operatingMode.radar==TRUE]/newObstacleState = getRadar(); \n if(newObstacleState != obstacleState){obstacleState = newObstacleState; \n myIdRobot = getIdRobot(); setRadar(idRobot,obstacleState); log(DEBUG, msg)}
						choice1 -> Piloting[H] : [else]
					`,
					features: String.raw`
						-obstacleRefreshPeriodCheck : Integer
						-obstacleState : Boolean

						+askCmd(cmd) : void

						-moveRobot(cmd) : void
					`,
				},
				{
					name: "stateIndicator",
					class: "StateIndicator",
					packagePath: [
						"SB_C",
					],
					behavior: String.raw`
						state "IDLE" as IDLE {
							state "choice" as choice <<choice>>
							state "emergency" as emergency {
							}
							emergency: do/notifyEmergency()
							emergency: entry/log(INFO, msg)
							state "selected" as selected {
							}
							selected : entry/notifySelected(); log(INFO, msg)
							selected : enableBuzzer()/ buzzerActivated = true; log(INFO, msg)
							selected : disableBuzzer()/ buzzerActivated = false; log(INFO, msg)
							selected : enableLED()/ ledActivated = true; log(INFO, msg)
							selected : disableLED()/ ledActivated = false; log(INFO, msg)
							state "notSelected" as notSelected {
							}
							notSelected : entry/notifyNotSelected(); log(INFO, msg)
							state "waitingForConnection" as waitingForConnection {
							}
							waitingForConnection : entry/log(INFO, msg)
							waitingForConnection : do/flashingForConnection()

							[*] -> waitingForConnection as "T1": / start
							choice -> waitingForConnection as "T2": [currentState == WAITING_FOR_CONNECTION]/
							choice -> waitingForConnection as "T3": [else]/
							choice -> selected as "T4": [currentState == SELECTED && !IN(waitingForConnection)]/
							choice -> notSelected as "T5": [currentState == NOT_SELECTED]/
							choice -> emergency as "T6": [currentState == EMERGENCY && IN(selected)]/
							emergency -> selected as "T7": after(emergencyTimeOut)/
						}
						[*] -> IDLE as "T1": /
							IDLE -> IDLE.choice as "T2": setState(state)/ currentState = state
					`,
					features: String.raw`
						-ledActivated : Bool
  						-buzzerActivated : Bool
						-currentState : State
						-emergencyTimeOut : Integer

						+setState(state) : void
						+enableBuzzer() : void
						+disableBuzzer() : void
						+enableLED() : void
						+disableLED() : void

						-flashingForConnection() : void
						-notifyNotSelected() : void
						-notifySelected() : void
						-notifyEmergency() : void
					`,
				},
			],
			connectorByName: {
				C1: {
					ends: [
						"guiSecretary",
						"configReader",
					],
					possibleMessages: {
						forward: [
							"getRobotListFromConfig():robotList",
						],
					},
				},
				C2: {
					ends: [
						"user",
						"gui",
					],
					possibleMessages: {
						forward: [
						"start()",
						"commandRobot()",
						"selectRobot(idRobot)",
						"moveRobot(selectedRobot, cmd)",
						"editRobotMode(selectedRobot, operatingMode)",
						"returnHome()",
						"consultLogs()",
						"selectLogs(idFile)",
						"exportLogs(idFile)",
						"flush()",
						"quit()",
						],
					},
				},
				C3: {
					ends: [
						"gui",
						"guiSecretary",
					],
					possibleMessages: {
						forward: [
							"askInit()",
							"getRobotList():Robot[*]",
							"setSelectedRobot(idRobot)",
							"changeMode(selectedRobot, operatingMode)",
							"disconnectRobots()",
							"setModeInit()",
							"reconnectingRobots()",
						],
						reverse: [
							"initReady()",
							"stop()",
							"modeReady()",
							"notifyError(idError)",
						]
					},
				},
				C4: {
					ends: [
						"gui",
						"logsManager",
					],
					possibleMessages: {
						forward: [
							"setSelectedLogs(idFile)",
							"log(level, msg)",
							"initFileList(robotList)",
						],
						reverse: [
							"setLogs(logList)",
							"logsReady(idFile, logList)",
						]
					},
				},
				C5: {
					ends: [
						"controllerLogger",
						"logsManager",
					],
					possibleMessages: {
						forward: [
							"setLogs(logList)",
						],
						reverse: [
							"askLogs(idRobot)",
							"logsSaved(idRobot)",
							"askSetRtc(idRobot, rtc)"
						],
					},
				},
				C6: {
					ends: [
						"pilot",
						"controllerLogger",
					],
					possibleMessages: {
						forward: [
							"log(level, msg)",
						],
					},
				},
				C7: {
					ends: [
						"guiSecretary",
						"controllerCore",
					],
					possibleMessages: {
						forward: [
							"askToConnect(idRobot)",
							"askToDisconnect(idRobot)",
							"askSetState(idRobot,state)",
							"askMode(idRobot)",
							"askSetMode(idRobot,operatingMode)",
						],
						reverse: [
							"setMode(idRobot, operatingMode)",
							"ackConnection(idRobot)",
							"disconnectedOk(idRobot)"
						],
					},
				},
				C8: {
					ends: [
						"controllerRinger",
						"guiRinger",
					],
					possibleMessages: {
						forward: [
							"setAvailability(idRobot)",
						],
						reverse: [
							"askAvailability(idRobot)",
						],
					},
				},
				C9: {
					ends: [
						"controllerCore",
						"camera",
					],
					possibleMessages: {
						forward: [
							"enableCamera()",
							"disableCamera()",
							"disconnectCamera()"
						],
						reverse: [
							"getIdRobot():Integer",
						],
					},
				},
				C10: {
					ends: [
						"controllerCore",
						"stateIndicator",
					],
					possibleMessages: {
						forward: [
							"setState(state)",
							"enableLED()",
							"disableLED()",
							"enableBuzzer()",
							"disableBuzzer()",
						],
					},
				},
				C11: {
					ends: [
						"pilot",
						"radar",
					],
					possibleMessages: {
						forward: [
							"getRadar() : Radar",
						],
					},
				},
				C12: {
					ends: [
						"camera",
						"viewer",
					],
					possibleMessages: {
						forward: [
							"setCamera(idRobot, myImage)",
						],
						reverse: [
							"setupGUIInfo(ip, port)",
						],


					},
				},
				C13: {
					ends: [
						"guiSecretary",
						"logsManager",
					],
					possibleMessages: {
						forward: [
							"checkFlushedSavedLogsFile(idFile)",
							"log(level, msg)",
							"transmitRtc(idRobot)"
						],
					},
				},
				C14: {
					ends: [
						"gui",
						"viewer",
					],
					possibleMessages: {
						forward: [
							"getLastCamera(idRobot) : Image",
						],
					},
				},
				C15: {
					ends: [
						"controllerCore",
						"controllerLogger",
					],
					possibleMessages: {
						forward: [
							"log(level, msg)",
						],
					},
				},
				C17: {
					ends: [
						"stateIndicator",
						"controllerLogger",
					],
					possibleMessages: {
						forward: [
							"log(level, msg)",
						],
					},
				},
				C18: {
					ends:[
						"controllerRinger",
						"controllerCore",
					],
					possibleMessages : {
						forward : [
							"connectionLost()",
						],
						reverse: [
							"initFailedPingsVar()",
						],
					}
				},
				C19: {
					ends: [
						"camera",
						"controllerLogger",
					],
					possibleMessages: {
						forward: [
							"log(level, msg)",
						],
					},
				},
				C20: {
					ends:[
						"controllerLogger",
						"gui",
					],
					possibleMessages : {
						forward : [
							"raiseMemoryAlert(idRobot)",
						]
					}
				},
				C21: {
					ends:[
						"guiRinger",
						"guiSecretary",
					],
					possibleMessages : {
						forward : [
							"getRobotList():Robot[*]",
							"notifyVarReady(idRobot)",
						],
						reverse: [
							"checkFailedPongVar(idRobot)",
							"initOK()",
						],
					}
				},
				C22 : {
					ends:[
						"gui",
						"pilot",
					],
					possibleMessages : {
						forward : [
							"askCmd(cmd)",
						],
						reverse: [
							"ackCmd(idRobot, cmd)",
						],
					},
				},
				C37 : {
					ends :[
						"pilot",
						"controllerCore",
					],
					possibleMessages : {
						forward : [
							"getIdRobot():Integer",
							"getMode():OperatingMode"
						],
						reverse : [
							"askCmd(cmd):void"
						]
					}
				},
				C23 : {
					ends :[
						"pilot",
						"stateIndicator",
					],
					possibleMessages : {
						forward : [
							"setState(state)"
						]
					}
				},
				C25 : {
					ends : [
						"pilot",
						"guiSecretary",
					],
					possibleMessages : {
						forward : [
							"setRadar(idRobot, myRadar)",
						]
					}
				},
				C27 : {
					ends: [
						"guiSecretary",
						"viewer",
					],
					possibleMessages: {
						forward: [
							"setupRobotPort(idRobot)",
						],
					},
				}
			},
			interactions:{
				PiloterUnEssaimDeRobots: String.raw`
					actor user
					participant gui
					participant logsManager
					participant guiSecretary
					participant controllerCore
					participant controllerLogger
					participant stateIndicator
					participant guiRinger
					participant controllerRinger
					participant camera
					participant viewer

					controllerCore 	-> controllerLogger 	: log(INFO, msg)
					ref over gui, controllerLogger : JournaliserEvenement

					controllerCore 	-> stateIndicator 		: setState(state)
					stateIndicator 	-> stateIndicator 		: flashingForConnection()
					stateIndicator 	-> controllerLogger 	: log(INFO, msg)
					ref over gui, controllerLogger : JournaliserEvenement

					user 			-> gui 					: start()
					gui 			-> logsManager 			: log(INFO, msg)
					logsManager 	-> logsManager 			: saveLogs(GUILogsFile, logList)
					gui 			-> gui 					: displayScreen(HOME_SCREEN, robotList)

					ref over gui, stateIndicator : Initialiser le systeme

					loop every refreshPingPeriod
						ref over guiSecretary, controllerRinger : VerifierConnexion
					end

					loop every streamRefreshRate
						ref over viewer, camera, controllerCore : TransmettreFluxCamera
					end

					user 			-> gui 					: commandRobot()
					gui 			-> logsManager 			: log(INFO, msg)
					logsManager 	-> logsManager 			: saveLogs(GUILogsFile, logList)

					gui 			-> guiSecretary 		: setModeInit()
                    ref over gui, camera  : RecupererModeFonctionnement
					guiSecretary 	-> gui 				: modeReady()
					e1 : gui 		-> guiSecretary 	: getRobotList()
					returning e1 	: Robot[*]
					gui 			-> gui 				: displayScreen(COMMAND_SCREEN, robotList)

					ref over gui, stateIndicator : Commander un robot

					ref over gui, stateIndicator : Quitter SB_IHM

				`,
				InitialiserLeSysteme: String.raw`
					participant configReader
					participant guiRinger
					participant logsManager
					participant guiSecretary
					participant viewer
					participant gui
					participant controllerLogger
					participant controllerCore
					participant controllerRinger
					participant stateIndicator
					participant camera

					gui -> guiSecretary : askInit()
					e0 : guiSecretary -> configReader : getRobotListFromConfig()
					configReader -> configReader : parseConfig(config)
					returning e0 : Robot[*]
					guiSecretary -> guiSecretary : pickFirstRobot(robotList)
					loop while there is still robot in robotList

						guiSecretary 		-> controllerCore 		: askToConnect(currentRobot.idRobot)
						guiSecretary 		-> logsManager 			: log(DEBUG, msg)
						logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
						controllerCore 		-> controllerLogger 	: log(DEBUG, msg)
						ref over gui, controllerLogger : JournaliserEvenement

						controllerCore 		-> guiSecretary 		: ackConnection(currentRobot.idRobot)
						controllerCore 		-> controllerLogger 	: log(INFO, msg)
						ref over gui, controllerLogger : JournaliserEvenement
						guiSecretary 		-> logsManager 			: log(INFO, msg)
						logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)

						controllerCore 		-> controllerRinger 	: initFailedPingsVar()
						controllerRinger	-> controllerRinger		: updateFailedPings(0)
						controllerCore 		-> stateIndicator 		: setState(state)
						stateIndicator 		-> stateIndicator 		: notifyNotSelected()
						stateIndicator 		-> controllerLogger 	: log(INFO, msg)
						ref over gui, controllerLogger : JournaliserEvenement

						guiSecretary 		-> logsManager 			: checkFlushedSavedLogsFile(RobotXLogsFile)
						logsManager 		-> logsManager 			: createFlushedLogsFile(RobotXLogsFile)

						guiSecretary 		-> guiRinger 			: checkFailedPongVar(currentRobot.idRobot)
						guiRinger 			-> guiRinger 			: createFailedPongVar(idRobot)
						guiRinger 			-> guiRinger 			: updateFailedPongs(0, idRobot)
						guiRinger 			-> guiSecretary 		: notifyVarReady(idRobot)

						guiSecretary 		-> logsManager 			: transmitRtc(currentRobot.idRobot)
						logsManager 		-> controllerLogger 	: askSetRtc(idRobot, rtc)
						logsManager 		-> logsManager 			: log(DEBUG, msg)
						logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
						controllerLogger 	-> controllerLogger 	: log(DEBUG, msg)
						ref over gui, controllerLogger : JournaliserEvenement

						controllerLogger 	-> controllerLogger 	: setUpRtc(rtc)
						guiSecretary 		-> viewer 				: setupRobotPort(idRobot)
						viewer 				-> camera 				: setupGUIInfo(ip, port)
						viewer 				-> logsManager 			: log(DEBUG, msg)
						logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
						camera		 		-> controllerLogger 	: log(DEBUG, msg)
						ref over gui, controllerLogger : JournaliserEvenement

						guiSecretary 		-> guiSecretary 		: updateConnectedRobot(idRobot, robotList)
						guiSecretary 		-> guiSecretary 		: pickNextRobot(robotList)
					end

					guiSecretary -> guiRinger : initOK()
					guiSecretary -> gui : initReady()
					e1 : gui -> guiSecretary : getRobotList()
					returning e1 : Robot[*]
					gui -> gui : updateCurrentScreen(robotList)
					gui -> logsManager : initFileList(robotList)
					logsManager -> logsManager : setFileList(robotList)
				`,
				SB_CSInitialise: String.raw`
					participant logsManager
					participant guiSecretary
					participant gui
					participant controllerLogger
					participant controllerCore
					participant controllerRinger
					participant stateIndicator

					guiSecretary 		-> controllerCore 		: askToConnect(currentRobot.idRobot)
					guiSecretary 		-> logsManager 			: log(DEBUG, msg)
					logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
					controllerCore 		-> controllerLogger 	: log(DEBUG, msg)
					ref over gui, controllerLogger : JournaliserEvenement

					controllerCore 		-> guiSecretary 		: ackConnection(idRobot)
					controllerCore 		-> controllerLogger 	: log(INFO, msg)
					ref over gui, controllerLogger : JournaliserEvenement
					guiSecretary 		-> logsManager 			: log(INFO, msg)
					logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)

					controllerCore 		-> controllerRinger 	: initFailedPingsVar()
					controllerRinger	-> controllerRinger		: updateFailedPings(0)
					controllerCore 		-> stateIndicator 		: setState(state)
					stateIndicator 		-> stateIndicator 		: notifyNotSelected()
					stateIndicator 		-> controllerLogger 	: log(INFO, msg)
					ref over gui, controllerLogger : JournaliserEvenement
				`,
				InitialiserUnNouveauRobotConnecte: String.raw`
					participant guiRinger
					participant logsManager
					participant guiSecretary
					participant viewer
					participant gui
					participant controllerLogger
					participant camera

					guiSecretary 		-> logsManager 			: checkFlushedSavedLogsFile(RobotXLogsFile)
					logsManager 		-> logsManager 			: createFlushedLogsFile(RobotXLogsFile)

					guiSecretary 		-> guiRinger 			: checkFailedPongVar(currentRobot.idRobot)
					guiRinger 			-> guiRinger 			: createFailedPongVar(idRobot)
					guiRinger 			-> guiRinger 			: updateFailedPongs(0, idRobot)
					guiRinger 			-> guiSecretary 		: notifyVarReady(idRobot)

					guiSecretary 		-> logsManager 			: transmitRtc(currentRobot.idRobot)
					logsManager 		-> controllerLogger 	: askSetRtc(idRobot, rtc)
					guiSecretary 		-> logsManager 			: log(DEBUG, msg)
					logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
					controllerLogger 	-> controllerLogger 	: log(DEBUG, msg)
					ref over gui, controllerLogger : JournaliserEvenement

					controllerLogger 	-> controllerLogger 	: setUpRtc(rtc)
					guiSecretary 		-> viewer 				: setupRobotPort(idRobot)
					viewer 				-> camera 				: setupGUIInfo(ip, port)
					viewer 				-> logsManager 			: log(DEBUG, msg)
					logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
					camera		 		-> controllerLogger 	: log(DEBUG, msg)
					ref over gui, controllerLogger : JournaliserEvenement
				`,
				RecupererModeFonctionnement : String.raw`
					participant logsManager
					participant guiSecretary
					participant gui
					participant controllerLogger
					participant controllerCore

					guiSecretary -> guiSecretary : pickFirstRobot(robotList)

					loop while there is still robot in robotList
						guiSecretary 		-> controllerCore 		: askMode(currentRobot.idRobot)
						guiSecretary 		-> logsManager 			: log(DEBUG, msg)
						logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)
						controllerCore 		-> controllerLogger 	: log(DEBUG, msg)
						ref over gui, controllerLogger : JournaliserEvenement

						controllerCore		-> guiSecretary 		: setMode(idRobot,operatingMode)
						controllerCore 		-> controllerLogger 	: log(DEBUG, msg)
						ref over gui, controllerLogger : JournaliserEvenement
						guiSecretary 		-> logsManager 			: log(DEBUG, msg)
						logsManager 		-> logsManager 			: saveLogs(GUILogsFile, logList)

						guiSecretary 		-> guiSecretary 		: pickNextRobot(robotList)
					end
				`,
				VerifierConnexion: String.raw`
					participant guiSecretary
					participant guiRinger
					participant logsManager
					participant gui
					participant controllerRinger
					participant controllerLogger

						e1 : guiRinger 			-> guiSecretary 		: getRobotList()
						returning e1 : Robot[*]
						guiRinger 				-> guiRinger			: pickFirstRobot(robotList)

						loop while there is still robot in robotList

							guiRinger 			-> controllerRinger 	: askAvailability(idRobot)
							guiRinger -> logsManager : log(DEBUG,msg)
							logsManager -> logsManager : saveLogs(GUILogFile,logList)
							controllerRinger -> controllerLogger : log(DEBUG, msg)
							ref over gui, controllerLogger : JournaliserEvenement
							controllerRinger 	-> controllerRinger 	: updateFailedPings(0)
							controllerRinger 	-> guiRinger 			: setAvailability(idRobot)
							controllerRinger -> controllerLogger : log(DEBUG, msg)
							ref over gui, controllerLogger : JournaliserEvenement
							guiRinger -> logsManager : log(DEBUG,msg)
							logsManager -> logsManager : saveLogs(GUILogFile,logList)
							guiRinger 			-> guiRinger 			: updateFailedPongs(0,idRobot)
							guiRinger 			-> guiRinger 			: pickNextRobot(robotList)
						end

				`,
				ConsulterLogsIhm: String.raw`
					actor user
					participant guiSecretary
					participant gui
					participant logsManager

					user 				-> gui 				: consultLogs()
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					e1 : gui 			-> guiSecretary 	: getRobotList()
					returning e1 : Robot[*]
					gui 				-> gui 				: displayScreen(LOGS_SCREEN,robotList)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					user 				-> gui 				: selectLogs(idFile)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					gui 				-> logsManager 		: setSelectedLogs(idFile)
					logsManager 		-> logsManager 		: loadLogs(idFile)
					logsManager 		-> gui 				: logsReady(idFile,logList)

					gui 				-> gui 				: displayLogs(idFile,logList)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
				`,
				ConsulterLogsRobot: String.raw`
					actor user
					participant guiSecretary
					participant gui
					participant logsManager
					participant controllerLogger

					user             	-> gui              : consultLogs()
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					e2 : gui         	-> guiSecretary     : getRobotList()
					returning e2 : Robot[*]
					gui              	-> gui              : displayScreen(LOGS_SCREEN,robotList)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					user             	-> gui              : selectLogs(idFile)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					gui              	-> logsManager      : setSelectedLogs(RobotXLogsFile)
					ref over a,b : FlusherLesLogs
					logsManager      	-> gui              : logsReady(RobotXLogsFile, logList)
					gui              	-> gui              : displayLogs(RobotXLogsFile, logList)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
				`,
				FlusherLesLogs: String.raw`
					participant logsManager
					participant controllerLogger
					participant gui

					logsManager    		-> controllerLogger : askLogs(idRobot)
					logsManager 		-> logsManager 		: log(DEBUG, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
					controllerLogger 	-> controllerLogger : log(DEBUG, msg)
					ref over gui, controllerLogger : JournaliserEvenement

					controllerLogger 	-> controllerLogger : loadLogs(idFile)
					controllerLogger 	-> logsManager      : setLogs(logList)
					controllerLogger 	-> controllerLogger : log(DEBUG, msg)
					ref over gui, controllerLogger : JournaliserEvenement
					logsManager 		-> logsManager 		: log(DEBUG, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					logsManager      	-> logsManager      : saveLogs(RobotXLogsFile, logList)
					logsManager      	-> controllerLogger : logsSaved(idRobot)
					logsManager 		-> logsManager 		: log(DEBUG, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					controllerLogger 	-> controllerLogger : removeLogs()
					controllerLogger 	-> controllerLogger : log(DEBUG, msg)
					ref over gui, controllerLogger : JournaliserEvenement

				`,
				ExporterLesLogs: String.raw`
					actor user
					participant gui
					participant logsManager

					user 				-> gui 				: exportLogs(idFile)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					gui 				-> logsManager	 	: askLogsExport(idFile)
					logsManager			-> logsManager 		: exportLogsWithOS(idFile)
					logsManager 		-> gui 				: logsExported(idFile)
				`,
				JournaliserEvenement: String.raw`
					participant gui
					participant controllerLogger

					controllerLogger -> controllerLogger : checkMemory()
					alt [memory<1,5]
						controllerLogger -> controllerLogger : saveLogs(msg,level)
					else [memory>=1,5 & memory<=2]
						controllerLogger -> gui : raiseMemoryAlert(idRobot)
					end
				`,
				CommanderUnRobot: String.raw`
					actor user
					participant logsManager
					participant gui
					participant guiSecretary
					participant viewer
					participant controllerCore
					participant controllerLogger
					participant stateIndicator

					user        	-> gui           	: selectRobot(idRobot)
					gui 			-> logsManager 		: log(INFO, msg)
					logsManager 	-> logsManager 		: saveLogs(GUILogsFile, logList)

					ref over a, b : Selectionner un robot

					alt User moves selected robot
						ref over a,b : Deplacer un robot
					else User edits Mode_Fonctionement of selected robot
						user 			-> gui 				: editRobotMode(selectedRobot,operatingMode)
						gui 			-> logsManager 		: log(INFO, msg)
						logsManager 	-> logsManager 		: saveLogs(GUILogsFile, logList)

						gui 			-> guiSecretary 	: changeMode(selectedRobot,operatingMode)
						guiSecretary 	-> controllerCore 	: askSetMode(idRobot, operatingMode)
						guiSecretary 	-> logsManager 		: log(DEBUG, msg)
						logsManager 	-> logsManager 		: saveLogs(GUILogsFile, logList)
						controllerCore	-> controllerLogger : log(DEBUG, msg)
						ref over a, b : JournaliserEvenement

						controllerCore 	-> controllerCore 	: setOperatingMode(operatingMode)
						controllerCore 	-> controllerCore 	: applyEditMode(operatingMode)
						e16 : gui 		-> guiSecretary 	: getRobotList()
						returning e16 	: robotList
						gui 			-> gui 				: updateCurrentScreen(robotList)
					else User selects a different robot
						user 			-> gui 				: selectRobot(idRobot)
						gui 			-> logsManager 		: log(INFO, msg)
						logsManager 	-> logsManager 		: saveLogs(GUILogsFile, logList)
						ref over a, b : Selectionner un robot
					end
				`,
				SelectionnerRobot: String.raw`
					participant logsManager
					participant guiSecretary
					participant gui
					participant controllerLogger
					participant stateIndicator
					participant controllerCore

					gui 				-> guiSecretary 	: setSelectedRobot(idRobot)
					guiSecretary		-> guiSecretary 	: selectedRobot = getRobotFromRobotList(idRobot)
					guiSecretary 		-> controllerCore 	: askSetState(idRobot, state)
					guiSecretary 		-> logsManager 		: log(DEBUG, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
					controllerCore		-> controllerLogger : log(DEBUG, msg)
					ref over a, b : JournaliserEvenement

					controllerCore 		-> stateIndicator 	: setState(state)
					stateIndicator 		-> stateIndicator 	: notifySelected()
					stateIndicator		-> controllerLogger : log(INFO, msg)
					ref over a, b : JournaliserEvenement

					e1 : gui 			-> guiSecretary 	: getRobotList()
					returning e1 : robotList
					gui 				-> gui 				: authorizeRobotCommand()
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
					gui 				-> gui 				: updateCurrentScreen(robotList)
				`,
				RafraichirEcranCommande: String.raw`
					participant gui
					participant viewer
					participant guiSecretary

					loop every streamRefreshRate
						e1 : gui 			-> guiSecretary 	: getRobotList()
						returning e1 		: Robot[*]
						gui 				-> gui 				: pickFirstRobot(robotList)
						loop while there is still robot in robotList
							gui 				-> gui 				: consultRobotMode(robotList, idRobot)
							gui 				-> gui 				: refreshRadarStream(radar,idRobot)
							gui 				-> gui 				: consultRobotMode(robotList, idRobot)
							e2 : gui			-> viewer 			: getLastCamera(idRobot)
							returning e2 : Image
							gui 				-> gui 				: refreshCameraStream(image, idRobot)
							gui 				-> gui 				: pickNextRobot(robotList)
						end
					end
				`,
				DeplacerRobot: String.raw`
					actor user
					participant guiSecretary
					participant logsManager
					participant gui
					participant pilot
					participant controllerLogger
					participant controllerCore
					participant radar
					participant stateIndicator

					loop every obstacleRefreshPeriodCheck
						ref over a, b : VerifierPresenceObstacle
					end

					user 				-> gui 				: moveRobot(selectedRobot,cmd)
					gui 				-> logsManager 		: log(INFO, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
					e1 : gui			-> guiSecretary 	: getRobotList()
					returning e1 		: Robot[*]
					gui 				-> gui 				: updateCurrentScreen(robotList)

					gui 				-> pilot 			: askCmd(cmd)
					gui 				-> logsManager 		: log(DEBUG, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
					pilot 				-> controllerLogger : log(DEBUG, msg)
					ref over a, b : JournaliserEvenement

					e2 : pilot 				-> controllerCore	: getIdRobot()
					returning e2		: idRobot
					pilot 				-> gui 				: ackCmd(idRobot,cmd)
					pilot 				-> controllerLogger	: log(DEBUG, msg)
					ref over a, b : JournaliserEvenement
					gui 				-> logsManager 		: log(DEBUG, msg)
					logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

					pilot 				-> pilot 			: moveRobot(cmd)
					pilot 				-> controllerLogger	: log(INFO, msg)
					ref over a, b : JournaliserEvenement
				`,
				VerifierPresenceObstacle: String.raw`
					participant logsManager
					participant guiSecretary
					participant pilot
					participant controllerCore
					participant radar
					participant stateIndicator
					participant controllerLogger
					participant gui

					e1 : pilot 			-> controllerCore 	: getMode()
					returning e1 		: operatingMode
					alt [radar activated]
						e2 : pilot 			-> radar 			: getRadar()
						returning e2 : newObstacleState

						alt [newObstacleState different from current obstacleState]
							e3 : pilot 			-> controllerCore	: getIdRobot()
							returning e3		: idRobot
							pilot 				-> guiSecretary 	: setRadar(idRobot, myRadar)
							pilot 				-> controllerLogger	: log(DEBUG, msg)
							ref over gui, controllerLogger : JournaliserEvenement
							guiSecretary 		-> logsManager 		: log(DEBUG, msg)
							logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
							alt [obstacleState==TRUE]
								pilot 				-> pilot 			: moveRobot(STOP)
								pilot 				-> controllerLogger	: log(INFO, msg)
								ref over gui, controllerLogger : JournaliserEvenement
								pilot 				-> stateIndicator : setState(state)
								stateIndicator 		-> stateIndicator : notifyEmergency()
								stateIndicator 		-> controllerLogger	: log(INFO, msg)
								ref over gui, controllerLogger : JournaliserEvenement
								...after(alarmEmergencyTime)...
								stateIndicator 		-> stateIndicator : notifySelected()
								stateIndicator 		-> controllerLogger : log(INFO, msg)

							end
						end
					end
				`,
				TransmettreFluxCamera: String.raw`
					participant viewer
					participant camera
					participant controllerCore

					camera 				-> camera 			: updateCamera()
					e1 : camera 				-> controllerCore	: getIdRobot()
					returning e1		: idRobot
					camera 				-> viewer 			: setCamera(myIdRobot,myImage)
				`,
				QuitterSB_IHM: String.raw`
					actor user
					participant gui
					participant logsManager
					participant guiSecretary
					participant controllerCore
					participant controllerLogger
					participant stateIndicator
					participant camera
					participant pilot

					user 			-> gui 				: quit()
					gui 			-> logsManager 		: log(INFO, msg)
					logsManager 	-> logsManager 		: saveLogs(GUILogsFile, logList)

					gui 			-> guiSecretary 	: disconnectRobots()
					guiSecretary 	-> guiSecretary 	: pickFirstRobot(robotList)
					loop while there is still robot in robotList

						guiSecretary 		-> controllerCore 	: askToDisconnect(currentRobot.idRobot)
						guiSecretary 		-> logsManager 		: log(DEBUG, msg)
						logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)
						controllerCore 		-> controllerLogger	: log(DEBUG, msg)
						ref over a, b : JournaliserEvenement

						controllerCore 		-> guiSecretary 	: disconnectedOk(idRobot)
						controllerCore 		-> controllerLogger	: log(DEBUG, msg)
						ref over a, b : JournaliserEvenement
						guiSecretary 		-> logsManager 		: log(DEBUG, msg)
						logsManager 		-> logsManager 		: saveLogs(GUILogsFile, logList)

						controllerCore 		-> controllerCore 	: disconnectCore()
						controllerCore 		-> pilot		 	: askCmd(STOP)
						controllerCore 		-> camera		 	: disconnectCamera()
						controllerCore 		-> stateIndicator 	: setState(state)
						stateIndicator 		-> stateIndicator 	: flashingForConnection()
						stateIndicator 		-> controllerLogger	: log(INFO, msg)
						ref over a, b : JournaliserEvenement

						guiSecretary 		-> guiSecretary 	: updateDisconnectedRobot(currentRobot,robotList)
						guiSecretary 		-> guiSecretary 	: pickNextRobot(robotList)
					end
					guiSecretary 	-> gui 				: stop()
					gui 			-> logsManager 		: log(INFO, msg)
					logsManager 	-> logsManager 		: saveLogs(GUILogsFile, logList)
					gui 			-> gui 				: terminate()
				`,
			},
			settings: {
				display: {
					hideLinks: false,
					hideClasses: false,
					hideOperations: true,
					hideMethods: false,
					showPorts: false,
					showEndNames: false,
					hideStateMachines: true,
					hideOuterSMBoxes: true,
					showExplicitSM: false,
					hideStates: false,
					showPseudostateInvariants: false,
					hideSets: false,
					showTransitions: false,
				},
				semantics: {
					fireInitialTransitions: false,
					autoFireAfterChoice: true,
					autoReceiveDisabled: false,
					considerGuardsTrue: true,
					checkEvents: false,
					keepOneMessagePerTrigger: true,
					enableEventPools: true,
					matchpickFirstRobot: true,
					symbolicValues: false,
					reactiveSystem: false,
				},
				interface: {
				},
			},
		};
	document.write(`
		<iframe width="100%" height="100%" src='http://172.24.2.1/AnimUML.html#${encodeURIComponent(JSON.stringify(model)).replace(/'/g, '%27')}'></iframe>
	`);
</script>
</body>
